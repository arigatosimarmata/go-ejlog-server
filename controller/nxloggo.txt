package controller

import (
	"context"
	"ejol/ejlog-server/config"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"strings"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var (
	WarningLogger *log.Logger
	InfoLogger    *log.Logger
	ErrorLogger   *log.Logger
)

func init() {
	filename := "ejlog-server-" + time.Now().Format("20060102") + ".log"
	file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatal(err)
	}

	InfoLogger = log.New(file, "INFO", log.Ldate|log.Ltime|log.Lshortfile)
	WarningLogger = log.New(file, "WARNING", log.Ldate|log.Ltime|log.Lshortfile)
	ErrorLogger = log.New(file, "ERROR", log.Ldate|log.Ltime|log.Lshortfile)
}

func MultilineWincor(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	// ip_address := "1.142.17.164"
	ip_address, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil {
		// fmt.Fprintf(w, "Error : %s", err)
		ErrorLogger.Println(err)
		w.WriteHeader(http.StatusNotAcceptable)
	}
	tbl_name := "ej_" + strings.ReplaceAll(ip_address, ".", "_")
	tbl_withdraw := "ejlog_withdraw"
	tbl_print_cash := "ejlog_print_cash"
	tbl_emergency_receipt := "ejlog_emergency_receipt"
	tbl_addcash := "ejlog_add_cash"

	ip := r.Header.Get("X-REAL-IP")
	ips := r.Header.Get("X-FORWARDED-FOR")
	// fmt.Fprintf(w, "Welcome Go Ejlog Server! From IP : %q And IPs : %q", string(ip), string(ips))
	InfoLogger.Println("ip ", ip_address, " - ips ", ips)

	kanwil, err := checkIpValid(ip_address)
	if err != nil {
		ErrorLogger.Println(err)
		log.Printf("Ip not found, error : %s", err)
		return
	}

	err_data := checkTable(tbl_name, kanwil)
	if err_data != nil {
		ErrorLogger.Println(err_data)
		log.Printf("Table not found, error : %s", err_data)
	}

	dbname := "ejlog_" + "20" + "_" + time.Now().Format("20060102") //make format dbname : ejlog_kanwil_yyyymmdd
	requestBody, _ := ioutil.ReadAll(r.Body)
	ejol_map := strings.Split(string(requestBody), "\n")
	// fmt.Println(len(ejol_map))
	db := config.DbConn(dbname)
	tx, err := db.Begin()
	if err != nil {
		log.Printf("open mysql database fail %s", err)
		ErrorLogger.Println(err)
		return
	}

	//insert data
	for _, element := range ejol_map {
		result, err := tx.Exec("INSERT INTO "+tbl_name+" (ip_address, ejlog) VALUES(?, ?)", ip_address, element)
		if err != nil {
			fmt.Println("Insert Data error :", err)
			ErrorLogger.Println(err)
			// tx.Rollback()
			return
		}
		tblej_id, _ := result.LastInsertId() //getLastIndex Executed

		//WITHDRAW
		if strings.Contains(element, "SWITCHING") {
			_, err := tx.Exec("INSERT INTO `"+tbl_withdraw+"`(`index`, `dbname`, `ip_address`, `ejlog`, `is_read`) VALUES (?, ?, ?, ?, ?)", tblej_id, tbl_name, ip_address, element, 0)
			if err != nil {
				fmt.Println("Insert WD error :", err)
				ErrorLogger.Println("Insert withdraw error : ", err)
				tx.Rollback()
				return
			}
		}

		//PRINT CASH
		if strings.Contains(element, "PRINTCASH") ||
			strings.Contains(element, "IDR,IDR,IDR,IDR") ||
			strings.Contains(element, "TYPE1TYPE2") ||
			strings.Contains(element, "CASHTOTALTYPE1TYPE2") ||
			strings.Contains(element, "[020t[05pTYPE1TYPE2") ||
			strings.Contains(element, "#CURDENOCST+REJ=REM+DISP=TOTAL") ||
			strings.Contains(element, "CURDENOINITDISPDEPCSTRJ") ||
			strings.Contains(element, "CASHCOUNTINFO") {
			_, err := tx.Exec("INSERT INTO `"+tbl_print_cash+"`(`index`, `dbname`, `ip_address`, `ejlog`, `is_read`) VALUES (?, ?, ?, ?, ?)", tblej_id, tbl_name, ip_address, element, 0)
			if err != nil {
				fmt.Println("Insert PC error :", err)
				ErrorLogger.Println("Insert print_cash error : ", err)
				ErrorLogger.Println(err)
				tx.Rollback()
				return
			}
			ErrorLogger.Println("Data tersedia ", element)
		}

		//EMERGENCY RECEIPT
		if strings.Contains(element, "EMERGENCYRECEIPT") ||
			strings.Contains(element, "TRANSACTIONJRNLTRANSACTION") ||
			strings.Contains(element, "PLEASECONTACTBRANCH") {
			_, err := tx.Exec("INSERT INTO `"+tbl_emergency_receipt+"`(`index`, `dbname`, `ip_address`, `ejlog`, `is_read`) VALUES (?, ?, ?, ?, ?)", tblej_id, tbl_name, ip_address, element, 0)
			if err != nil {
				fmt.Println("Insert ER error :", err)
				ErrorLogger.Println("Insert emergency_receipt error : ", err)
				tx.Rollback()
				return
			}
		}

		//ADD CASH
		if strings.Contains(element, "ADDCASH") ||
			strings.Contains(element, "CASHCOUNTERS") ||
			strings.Contains(element, "[05pCASHADDED") ||
			strings.Contains(element, "CLEARCASH") ||
			strings.Contains(element, "REPLENISHMENT") {
			_, err := tx.Exec("INSERT INTO `"+tbl_addcash+"`(`index`, `dbname`, `ip_address`, `ejlog`, `is_read`) VALUES (?, ?, ?, ?, ?)", tblej_id, tbl_name, ip_address, element, 0)
			if err != nil {
				fmt.Println("Insert AC error :", err)
				ErrorLogger.Println("Insert add_cash error : ", err)
				tx.Rollback()
				return
			}
		}
	}
	tx.Commit()
	defer db.Close()

	elapsed := time.Since(start)
	log.Printf("This request took %s ", elapsed)
	log.Println("RC : 200 ")
	InfoLogger.Println("Data Saved : ", ip)
	w.WriteHeader(http.StatusOK)
	// http.Redirect(w, r, "/", 301)
}

func checkTable(tbl_name, kanwil string) error {
	dbname := "ejlog_" + kanwil + "_" + time.Now().Format("20060102")

	db := config.DbConn(dbname)
	query := `CREATE TABLE IF NOT EXISTS ` + tbl_name + `(
		id INT(10) NOT NULL AUTO_INCREMENT,
		ip_address VARCHAR(50) NOT NULL,
		row_ej VARCHAR(10) NULL DEFAULT NULL,
		ejlog LONGTEXT NOT NULL,
		header_ej VARCHAR(100) NULL DEFAULT NULL,
		is_curl VARCHAR(2) NOT NULL DEFAULT '1',
		created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
		updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
		deleted_at TIMESTAMP NULL DEFAULT NULL,
		PRIMARY KEY(id) USING BTREE
		)`

	ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancelfunc()
	_, err := db.ExecContext(ctx, query)
	if err != nil {
		ErrorLogger.Printf("Error %s when creating ejlog table - ", err)
		return err
	}
	defer db.Close()

	return nil
}

func checkIpValid(ip_address string) (string, error) {
	var tid, ip_atm, _type, kanwil2 string
	db := config.DbConn("ejlog3")
	err := db.QueryRow("select tid, ip_address, type, kanwil2 from atm_mappings where ip_address = ? limit 1", ip_address).Scan(&tid, &ip_atm, &_type, &kanwil2)
	if err != nil {
		return "", err
	}
	defer db.Close()

	return kanwil2, nil
}
